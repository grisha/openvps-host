#!/usr/bin/python

# $Id: ohd,v 1.1 2004/03/25 16:48:40 grisha Exp $

""" This is a little daemon-like program that facilitates the use
of ping, traceroute and other tools not available from within a
vserver.

"""
import asyncore
import asynchat
import socket
import os, sys, time
import marshal
import imp
from optparse import OptionParser
from syslog import syslog, openlog

openlog('ohd')

class Devnull:
    def write(self, msg): pass
    def flush(self): pass
    
#DEBUGSTREAM = sys.stdout
DEBUGSTREAM = Devnull()

ARGUMENT_ERROR = 'ArgumentError'

class DaemonOptParser(OptionParser):

    def __init__(self, usage, channel):
        OptionParser.__init__(self, usage)
        self.channel = channel

    def error(self, msg):
        self.print_usage()
        self.channel.push('error: %s\n' % msg)
        self.channel.push('END OF COMMAND')
        self.channel = None # else the chanel isn't freed
        raise ARGUMENT_ERROR

    def print_usage(self, file=None):
        self.channel.push(self.get_usage()+'\n')

class Channel(asynchat.async_chat):
    COMMAND = 0
    OUTPUT = 1
    
    def __init__(self, conn):
        asynchat.async_chat.__init__(self, conn)
        self.__cpipe = None
        self.__line = []
        self.__state = self.COMMAND
        self.set_terminator('\r\n')

    def __del__(self):
        print >> DEBUGSTREAM, 'deleting'

    # Overrides base class for convenience
    def push(self, msg):
        self.log('OUT: %s' % `msg`)
        print >> DEBUGSTREAM, 'OUT:', `msg`
        asynchat.async_chat.push(self, msg)

    def log(self, data):
        peer = self.getpeername()
        syslog('%s:%d %s' % (peer[0], peer[1], data))

    # Implementation of base class abstract method
    def collect_incoming_data(self, data):
        self.__line.append(data)

    # Implementation of base class abstract method
    def found_terminator(self):
        line = ''.join(self.__line)
        self.log('IN: %s' % `line`)
        print >> DEBUGSTREAM, 'Data:', repr(line)
        self.__line = []
        if self.__state == self.OUTPUT:
            channel = asyncore.socket_map[self.__cnl_id]
            channel.push(line+'\n')
        else:
            if not line:
                self.push('Error: bad syntax')
                return
            method = None
            i = line.find(' ')
            if i < 0:
                command = line.upper()
                arg = None
            else:
                command = line[:i].upper()
                arg = line[i+1:].strip()
            method = getattr(self, 'ohsmp_' + command, None)
            if not method:
                self.push('Error: command "%s" not implemented' % command)
                return
            method(arg)
            return

##     def ohsmp_WHOAMI(self, arg):
##         cfg = get_config_by_ip()
##         self.push(marshal.dumps(cfg[self.getpeername()[0]]))
##         self.close_when_done()

    def ohsmp_PING(self, arg):
        if os.name == 'nt':
            c_opt = '-n'
        else:
            c_opt = '-c'
        usage = 'ping [%s count] host' % c_opt
        parser = DaemonOptParser(usage, self)
        parser.add_option(c_opt, dest="count", type="int",
                          help="Number of echo requests to send",
                          default=0)
        try:
            (options, args) = parser.parse_args(arg.split())
            if len(args) != 1:
                parser.error('Incorrect number of arguments')
            if options.count > 10:
                parser.error('Sorry, a maximum of 10 ICMP packets is allowed.')
            if options.count == 0:
                # arg = c_opt + ' 4 -t 5 ' + arg # BSD
                arg = c_opt + ' 4 -W 5 ' + arg
            else:
                # arg = ('-t %d ' % (options.count + 1)) + arg # BSD
                arg = ('-W %d ' % (options.count + 1)) + arg
        except ARGUMENT_ERROR:
            self.close_when_done()
            return

        self._spawn_command('ping', arg)

    def ohsmp_TRACEROUTE(self, arg):
        if os.name == 'nt':
            cmd = 'tracert'
            usage = 'tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name'
        else:
            cmd = 'traceroute'
            usage = 'USAGE GOES HERE'

        parser = DaemonOptParser(usage, self)
        parser.add_option('-d', action='store_true',
                          help="Do not resolve addresses to hostnames")

        try:
            (options, args) = parser.parse_args(arg.split())
            if len(args) != 1:
                parser.error('Incorrect number of arguments')
        except ARGUMENT_ERROR:
            self.close_when_done()
            return

        self._spawn_command(cmd, arg)

    def ohsmp_DF(self, arg):
        if os.name == 'nt':
            cmd = 'tracert'
            usage = 'tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name'
        else:
            cmd = 'traceroute'
            usage = 'USAGE GOES HERE'

        parser = DaemonOptParser(usage, self)
        # XXX df options here
        try:
            (options, args) = parser.parse_args(arg.split())
            if len(args) != 1:
                parser.error('Incorrect number of arguments')
        except ARGUMENT_ERROR:
            self.close_when_done()
            return

        self._spawn_command('tracert', arg)

    def _spawn_command(self, command, arg):
        # what we're doing here is launching a separate
        # process, which will make a connection to us and
        # feed the output from the command using the OUTPUT
        # command. This is a compromize because I'm writing this
        # on Windows, and there is no select() on popen. (XXX ?)
        os.spawnv(os.P_NOWAIT, sys.executable,
                  ['python', '/usr/local/sbin/ohd_child', str(self._fileno),
                   command] + arg.split())
        
    def ohsmp_OUTPUT(self, arg):
        if not arg:
            self.push("OUTPUT takes an argument")
            self.close_when_done()
        elif self.getpeername()[0] != '127.0.0.1':
            self.close()
        else:
            cnl_id = int(arg)
            if not asyncore.socket_map.has_key(cnl_id):
                self.push("Error: No such channel: %d" % cnl_id)
                self.close_when_done()
            else:
                self.__state = self.OUTPUT
                self.__cnl_id = cnl_id
                self.set_terminator('\n')

class Server(asyncore.dispatcher):

    def __init__(self, localaddr):
        asyncore.dispatcher.__init__(self)
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.set_reuse_addr()
        self.bind(localaddr)
        self.listen(5)
        print >> DEBUGSTREAM, \
              '%s started at %s\n\tLocal addr: %s\n' % (
            self.__class__.__name__, time.ctime(time.time()),
            localaddr)

    def handle_accept(self):
        conn, addr = self.accept()
        print >> DEBUGSTREAM, 'Incoming connection from %s' % repr(addr)
        #cfg = get_config_by_ip()
        #if cfg.has_key(addr[0]) or addr[0] == '127.0.0.1':
        channel = Channel(conn)
        print >> DEBUGSTREAM, 'channel created:', channel
        #else:
        #    syslog("Connection refused for %s" % `addr`)
        #    print >> DEBUGSTREAM, 'I dont talk to foreigners'
        #    conn.close()
            

srv = Server(('', 1010))
asyncore.loop()
